<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Brick Breaker Simple</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    overflow: hidden;
    background: radial-gradient(circle at 30% 30%, #1a2236, #0b0f1a);
  }
  canvas {
    display: block;
    width: 100%;
    height: 100%;
    background: transparent;
    touch-action: none;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  let W, H, dpr;

  function resize() {
    dpr = window.devicePixelRatio || 1;
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resize);
  resize();

  // Game state
  let score = 0;
  let highScore = parseInt(localStorage.getItem("bb_highscore") || "0");
  let lives = 3;
  let level = 1;
  let paused = false;

  const paddle = { x: W/2 - 60, y: H - 40, w: 120, h: 12, speed: 8 };
  const ball = { x: W/2, y: H/2, r: 8, vx: 4, vy: -4 };
  const bricks = [];
  const brickRows = 5, brickCols = 8;
  const brickMargin = 8;
  const brickW = (W - brickMargin*(brickCols+1)) / brickCols;
  const brickH = 24;

  function makeBricks() {
    bricks.length = 0;
    for (let r=0;r<brickRows;r++){
      for (let c=0;c<brickCols;c++){
        bricks.push({
          x: brickMargin + c*(brickW+brickMargin),
          y: 60 + r*(brickH+brickMargin),
          w: brickW,
          h: brickH,
          alive: true
        });
      }
    }
  }
  makeBricks();

  // Controls
  let left=false,right=false;
  window.addEventListener("keydown", e=>{
    if(e.key==="ArrowLeft"||e.key==="a") left=true;
    if(e.key==="ArrowRight"||e.key==="d") right=true;
    if(e.key===" "){ paused=!paused; }
  });
  window.addEventListener("keyup", e=>{
    if(e.key==="ArrowLeft"||e.key==="a") left=false;
    if(e.key==="ArrowRight"||e.key==="d") right=false;
  });

  // Mouse/touch move
  canvas.addEventListener("mousemove", e=>{
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    paddle.x = x - paddle.w/2;
  });
  canvas.addEventListener("touchmove", e=>{
    const rect = canvas.getBoundingClientRect();
    const x = e.touches[0].clientX - rect.left;
    paddle.x = x - paddle.w/2;
  }, {passive:true});

  function resetBall() {
    ball.x = paddle.x + paddle.w/2;
    ball.y = paddle.y - ball.r - 2;
    ball.vx = 4 * (Math.random()>0.5?1:-1);
    ball.vy = -5;
  }

  function nextLevel() {
    level++;
    makeBricks();
    resetBall();
  }

  function loseLife() {
    lives--;
    if(lives<=0) {
      if(score > highScore){
        highScore = score;
        localStorage.setItem("bb_highscore", highScore);
      }
      score = 0; lives = 3; level = 1;
      makeBricks();
    }
    resetBall();
  }

  function update() {
    if(paused) return;

    // Move paddle
    if(left) paddle.x -= paddle.speed;
    if(right) paddle.x += paddle.speed;
    paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));

    // Move ball
    ball.x += ball.vx;
    ball.y += ball.vy;

    // Collide walls
    if(ball.x < ball.r || ball.x > W - ball.r) ball.vx *= -1;
    if(ball.y < ball.r) ball.vy *= -1;
    if(ball.y > H) loseLife();

    // Collide paddle
    if(ball.y + ball.r >= paddle.y && ball.x > paddle.x && ball.x < paddle.x + paddle.w && ball.vy > 0){
      const hitPos = (ball.x - (paddle.x + paddle.w/2)) / (paddle.w/2);
      ball.vx = hitPos * 6;
      ball.vy = -Math.abs(ball.vy);
    }

    // Collide bricks
    for(const br of bricks){
      if(!br.alive) continue;
      if(ball.x > br.x && ball.x < br.x + br.w &&
         ball.y - ball.r < br.y + br.h && ball.y + ball.r > br.y){
        br.alive = false;
        ball.vy *= -1;
        score += 10;
      }
    }

    // Check level clear
    if(bricks.every(b=>!b.alive)){
      nextLevel();
    }
  }

  function draw() {
    ctx.clearRect(0,0,W,H);

    // Bricks
    for(const br of bricks){
      if(!br.alive) continue;
      const g = ctx.createLinearGradient(br.x, br.y, br.x, br.y+br.h);
      g.addColorStop(0,"#4ef");
      g.addColorStop(1,"#27a");
      ctx.fillStyle = g;
      ctx.fillRect(br.x, br.y, br.w, br.h);
    }

    // Paddle
    ctx.fillStyle = "#fff";
    ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);

    // Ball
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
    ctx.fillStyle = "#ffd166";
    ctx.fill();

    // Text
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.font = "16px Arial";
    ctx.fillText(`Score: ${score}`, 16, 24);
    ctx.fillText(`High: ${highScore}`, 16, 44);
    ctx.fillText(`Lives: ${lives}`, W - 100, 24);
    ctx.fillText(`Level: ${level}`, W - 100, 44);

    if(paused){
      ctx.font = "24px Arial";
      ctx.fillText("PAUSED", W/2 - 50, H/2);
    }
  }

  function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
  }
  resetBall();
  loop();
})();
</script>
</body>
</html>
